#아이템 7 다 쓴 객체 참조를 해제하라

### 개요
- 가비지 컬렉터가 있는 언어들은 메모리를 신경쓰지 않아도 된다고 생각할 수 있지만 결코 아니며 메모리 누수가 일어날 수 있다.
- 메모리 누수를 막고 메모리의 관리의 중요성을 알아보자.

### 메모리를 직접 관리하는 클래스
- 메모리를 직접 관리하는 Stack은 Stack이 커졌다가 줄어들 떄 Stack에서 꺼내진 객체들을 가비지 컬렉터가 회수하지 않는다.
- 이를 비활성 영역이라고 하며 가비지 컬렉터가 비활성 영역이 사용하지 않는 레퍼런스라는 것을 알 방법이 없다.
- 이러한 문제는 null처리로 간단하게 참조 해제를 함으로써 해결할 수 있지만 남용하는 것은 바람직 하지 않고 프로그램을 필요 이상으로 지저분 하게 만들 뿐이다.


### 객체 참조를 null처리 하는 일은 예외적인 경우여야 한다.
- Stack과 같이 메모리 누수에 취약하고 자기 메모리를 직접 관리하는 경우
- 비활성 영역에서 참조이 있어 가비지 컬렉터가 이사싱을 알 길이 없는 경우

### 캐시 역시 메모리 누수를 일으키는 주범이다.
- 캐시 역시 메모리 누수를 일으키는 주범이다. 객체의 레퍼런스를 캐시에 넣어 놓고 캐시를 비우는 것을 잊기 쉽다.
- WeakHashMap을 사용 할 수 있다.
  - WeakHashMap 은 특정 key 값이 더이상 사용되지 않는다고 판단되면 해당 Key - Value 쌍을 삭제해준다.
  - 캐시의 키에 대한 레퍼런스가 캐시 밖에서 필요 없어지면 엔트리를 캐시에서 자동으로 비워주는 역할이다.
- 새로운 엔트리를 추가할 때 부가적인 작업으로 기존 캐시를 비우는 일이다.
  - 캐시를 만들 때 보통 캐시 엔트리의 유효기간을 정확히 정의하기 어렵기 때문에 시간이 지날수록 엔트리의 가치를 떨어뜨리는 방식을 사용한다.
  - LinkedHashMap - removeEldestEntry()
  - removeEldestEntry() 는 들어온 순서를 기억하고, 특정 사이즈까지 도달하게 된다면 가장 오래된 값을 지우고 그 자리에 방금 들어온 값을 대체합니다.

```java
  protected boolean removeEldestEntry(Map.Entry<K,V> eldest){
    return size() == 6? : true : false;
  }
  // size가 6을 넘어 가면 가장 오래된 값을 지우고 새로운 값으로 대체한다.
```

### 리스너(listener) 혹은 콜백(callback) 또한 메모리 누수를 부른다.
- 클라이언트가 콜백을 등록만 하고 해지하지 않는다면 콜백은 계속 쌓여만 갈 것이다.
- 이럴 때 콜백을 약한 참조(weak reference)로 저장하면 가비지 컬렉터가 즉시 수거해간다.
- 해결방법으로 WeakHashMap을 사용할 수 있다.

### 결론
- 자바가 가비지 컬렉터를 가지고 있다고 해서 메모리를 신경안써야 되는것은 아니며 항상 코드리뷰나 주기적인 메모리 누수 점검을 해야한다.



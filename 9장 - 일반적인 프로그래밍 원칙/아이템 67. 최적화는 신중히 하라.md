# 67장. 최적화는 신중히 하라

섣불리 최적화를 진행하면 해로운 결과로 이어지기 쉽다. 

느리고 제대로 동작하지 않으면서 수정하기 어려운 소프트웨어가 될 수 있다.

따라서 **최적화로 인해 빠른 프로그램보다 좋은 프로그램을 만들어야 한다.** 

여기서 좋은 프로그램이란 정보은닉(information hiding)을 준수한다.
그로 인해 개별 구성요소의 내부를 독립적으로 설계할 수 있어 시스템의 나머지에 영향을 주지 않고도 각 요소를 다시 설계할 수 있다.

그렇다 해서 완전히 성능 문제를 무시하라는 뜻은 아니다.

### 1. **성능을 제한하는 설계를 피하라**

완성 후 변경하기 어려운 설계 요소는 컴포넌트 간 혹은 외부 시스템과의 소통 방식이다. 이러한 경우 시스템 성능을 제한하지 않는 설계가 필요하다.

### **2. API를 설계할 때 성능에 주는 영향을 고려하자.**

2-1. public 타입을 가변으로 만들어 내부 데이터를 변경할 수 있다면, 불필요한 방어적 복사를 유발할 수 있다.

2-2. 컴포지션으로 해결할 수 있음에도 상속으로 설계한 public 클래스는 상위 클래스에 종속되며, 성능 제약까지 물려받는다.

2-3. 인터페이스가 있는데 구현 타입을 사용하면 특정 구현 타입에 종속되어 나중에 더 빠른 구현체가 나오더라도 사용할 수 없게 된다.

### 3. 성능을 위해 API를 왜곡하는 것은 좋지 않다.

성능 문제를 위해 왜곡된 API를 만들게 되면, 지금 당장의 성능 이슈는 해결될지 몰라도 그 API를 지원하는데 따르는 고통은 영원히 계속될 것이다. 

### 추가할만한 최적화 규칙은?

성능 최적화를 시도한 구간에 성능 측정을 하라

- 프로파일링 도구는 최적화의 집중할 곳을 찾는데 도움을 준다.
    - 런타임 정보를 제공
    - 시스템에 많은 코드가 작성될 수록, 프로파일러를 사용하는 것이 중요
- 자바는 C와 C++보다 최적화의 영향을 측정하는 것이 중요하다.
    - 프로그래머가 작성하는 코드와 CPU에서 수행하는 명령 사이의 “추상화 격차”가 커서 성능 변화를 예측하기 어려움

**결론**

성능보다는 견고한 구조의 프로그램을 작성하자

견고한 구조의 프로그램을 작성하다보면 성능은 자연스레 따라온다

성능을 측정했을 때, 충분히 빠르다면 최적화를 하지 않아도 괜찮다.
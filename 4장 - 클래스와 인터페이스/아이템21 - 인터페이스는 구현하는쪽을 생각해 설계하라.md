# 아이템21 -  인터페이스는 구현하는쪽을 생각해 설계하라


## 구현체가 존재하는 상황에서 새로운 메서드를 인터페이스 추가하는 방법?

- Java8 이전에는 기존 구현체를 깨뜨리지 않고 인터페이스에 메서드를 추가할 방법은 없었지만 Java8의 default mehtod를 사용하면 기존 인터페이스에 새로운 메서드를 구현체에 영향을 주지 않고 추가할 수 있다.
- 하지만, 디폴트 메서드가 추가된다하더라도 모든 구현체들과 호환되는것은 아님을 주의하라

- 아래코드는 Collection인터페이스의 removeIf 디폴트 메서드인데 SynchronizedCollection구현체와는 호환되지 않는다. 해당 구현체는 락을 거는 기능이 있는데 아래의 디폴트메서드에서는 락에대한 처리가 전혀 없다. 즉, 동시성 문제가 생길 가능성이 있다.

```java

default boolean removeIf(Predicate<? super E> filter) {
        Objects.requireNonNull(filter);
        boolean result = false;
        for (Iterator<E> it = iterator(); it.hasNext();){
            if(filter.test(it.next())){
                it.remove();
                result = true;
            }
        }
        return result;
}

```




## 디폴트메서드와 기존 구현체간의 동기화 유지 방법

- 구현한 인터페이스의 디폴트 메서드를 재정의하고, 다른 메서드 에서는 디폴트 메서드를 호출하기 전에 필요한 작업을 수행하도록 했다.
- SynchronizedCollection 4.4버전부터는 아래와같이 lock처리를 했다.
- 디폴트 메서드는 (컴파일에 성공하더라도) 기존 구현체에 런타임 오류를 일으킬 수 있다. 자바 8은 컬렉션 인터페이스에 꽤 많은 디폴트 메서드를 추가했고, 그 결과 기존에 짜여진 많은 자바 코드가 영향을 받은 것으로 알려졌다.
- 디폴트 메서드는 인터페이스로부터 메서드를 제거하거나 기존 메서드의 시그니처를 수정하는 용도가 아님을 명심해야 한다. 이런 형태로 인터페이스를 변경하면 반드시 기존 클라이언트를 망가뜨리게 된다.

```java

	/**
    * @since 4.4
    */
    @Override
    public boolean removeIf(final Predicate<? super E> filter) {
        synchronized (lock) {
            return decorated().removeIf(filter);
        }
    }




```




## 정리 및 느낀점

- 결국 default method는 기존 구현체와의 호환성을 유지하면서 새로운 메서드를 추가시키기 위한 도구이다. 결국, 새로운 메서드를 손쉽게 추가한다는 장점이 있지만 기존 구현체에 완전히 영향없이 메서드를 추가하는것은 거의 불가능하다.
- 편하게 추가할수 있는것 처럼 보이지만 결국 새로추가한 인터페이스 메서드가 모든 구현체에서 정상적으로 돌아가는지 확인하는 작업은 필수이다. 
- 아이템 21의 제목인 `인터페이스는 구현하는쪽을 생각해 설계하라` 라는 의미가 아이템21의 내용과 어떤부분을 이야기하는건지 조금 더 고민해봐야할듯..
	- 결국 default method로 새로운 메서드를 추가할 수 있지만 구현체 입장에서 해당 메서드가 호환이 되는지 다시 한번 생각하라는 의미인가?
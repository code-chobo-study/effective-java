## 예외는 진짜 예외상황에서만 사용

- 예외는 오직 `예외상황`에서만 사용해라
- 아래 코드는 무한 루프를 돌다가 배열의 끝에 도달하면서 예외가 발생하는 코드인데 ArrayIndexOutOfBoundsException을 catch하고있다
	- try-catch를 불필요하게 사용하면 jvm최적화가 제한 -> 일반적인 코드와 try-catch로 감싼 코드의 성능이 다름
	- ArrayIndexOutOfBoundException이 아닌 다른 버그가 숨어있더라도 ArrayIndexOutOfBoundException이 throw되면서 다른 예외를 잡지 못할수도 있음
- 즉, 배열의 요소에 접근할때 배열의 `0번째 요소 ~ 배열의길이 -1` 의 범위에 포함되지 않은 인덱스에 접근하려고하면 ArrayIndexOutOfBoundsException을 throw한다. 즉 ,jvm단에서 자체적으로 접근하지 못하는 요소에 접근하려고 했으니 잘못되었다고 알려주고있다. ArrayIndexOutOfBoundsException은 런타임익셉션이며 확인되지 않은 예외이므로 메서드에서 명시 적으로 호출 할 필요가 없다.
	- 개발자의 실수로 발생하는 exception이다
		- 배열은 항상 1이 아닌 인덱스 0으로 시작한다. 마찬가지로 배열의 마지막 요소는 'arraylength'가 아닌 'arraylength-1'인덱스를 사용하여 액세스 할 수 있습니다. 프로그래머는 배열 제한을 사용하는 동안주의해야하며 따라서 ArrayIndexOutOfBoundsException을 피해야한다.
		- 향상된 for 루프 또는 for-each 루프는 배열과 같은 연속적인 메모리 위치를 반복하고 유효한 인덱스에만 액세스한다. 따라서 향상된 for 루프를 사용할 때 잘못된 인덱스 나 잘못된 인덱스에 액세스하는 것에 대해 걱정할 필요가 없다.


```java

	try { 
		int i = 0; 
		while(true) { 
			 range[i++].climb(); 
		 } 
	 } 
	 catch (ArrayIndexOutOfBoundsException e) { 
	 
	 }

```




#### **예외 관점에서 잘 설계된 API란,**

- 잘 설계된 API는 클라이언트가 `정상적인 제어 흐름`에서 예외를 사용할 일이 없게 해야 한다.
	- 즉, '상태 의존적' 메소드를 제공하는 클래스는 '상태 검사' 메소드도 함께 제공해야 한다.
	- ex) Iterator 인터페이스의 next(상태 의존적 메소드)와 hasNext(상태 검사 메소드)를 제공한다.


```java

//Iterator 표준 관용구 사용 
for(Iterator<Foo> i = collection.iterator(); i.hashNext();) { 
	Foo foo = i.next(); ... 
}

```

만약 hasNext가 없으면 이런식으로 처리해야함..
```java

try{ 
	Iterator<Foo> i = collection.iterator();
	 while(true) { 
		oo foo = i.next(); ... 
	} 
} 
catch(NoSuchElementException e) { 

}

```